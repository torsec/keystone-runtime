#include <stddef.h>

#define ED25519_NO_SEED 1
#include "sha3/sha3.h"
/* Adopted from https://github.com/orlp/ed25519
  provides:
  - void ed25519_create_keypair(t_pubkey *public_key, t_privkey *private_key, t_seed *seed);
  - void ed25519_sign(t_signature *signature,
                      const unsigned uint8_t *message,
                      size_t message_len,
                      t_pubkey *public_key,
                      t_privkey *private_key);
*/

#include "ed25519/ed25519.h"
#include "x509/x509.h"
/* adopted from
  provides:
  - int sha3_init(sha3_context * md);
  - int sha3_update(sha3_context * md, const unsigned char *in, size_t inlen);
  - int sha3_final(sha3_context * md, unsigned char *out);
  types: sha3_context
*/

#include "string.h"
/*
  provides memcpy, memset
*/

static const unsigned char uds[] = {
  0x40, 0xa0, 0x99, 0x47, 0x8c, 0xce, 0xfa, 0x3a, 0x06, 0x63, 0xab, 0xc9,
  0x5e, 0x7a, 0x1e, 0xc9, 0x54, 0xb4, 0xf5, 0xf6, 0x45, 0xba, 0xd8, 0x04,
  0xdb, 0x13, 0xe7, 0xd7, 0x82, 0x6c, 0x70, 0x73};

static const unsigned char man_pub_key[] = {0x7f, 0x70, 0xec, 0x0c, 0x2a,
  0x76, 0x07, 0xd3, 0x1a, 0x0b, 0x89, 0xd6, 0x4e, 0x0f, 0x51, 0x4e, 0xf7,
  0x88, 0x7d, 0x45, 0xb3, 0x2b, 0x14, 0x8b, 0x82, 0x25, 0xd0, 0x72, 0xba,
  0xf0, 0x62, 0x08};

static const unsigned char man_priv_key[] = {0x20, 0x55, 0xca, 0x3e, 0x0c,
  0x24, 0x9d, 0xfd, 0xbc, 0xf9, 0x59, 0x8c, 0xae, 0x6c, 0xb9, 0xd6, 0x5d,
  0xec, 0x7c, 0x7c, 0xe3, 0x25, 0x6f, 0xee, 0x39, 0x16, 0x24, 0x86, 0xaa,
  0x33, 0xfb, 0x6a, 0x0e, 0x62, 0x6f, 0xa2, 0x55, 0x87, 0xc9, 0x5f, 0xb7,
  0x35, 0x14, 0x25, 0x1e, 0x32, 0x62, 0x8c, 0xe8, 0x62, 0xc2, 0xba, 0xcc,
  0xfb, 0xc0, 0xfd, 0x9c, 0x14, 0x4f, 0x91, 0x7e, 0x46, 0xd9, 0x48};

static const unsigned char man_cert[] = {0x30, 0x82, 0x01, 0x07, 0x30,
  0x81, 0xb8, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x00, 0xff, 0x30,
  0x07, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x05, 0x00, 0x30, 0x17, 0x31, 0x15,
  0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x4d, 0x61, 0x6e,
  0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x30, 0x1e, 0x17,
  0x0d, 0x32, 0x33, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
  0x30, 0x5a, 0x17, 0x0d, 0x32, 0x37, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30,
  0x30, 0x30, 0x30, 0x30, 0x5a, 0x30, 0x17, 0x31, 0x15, 0x30, 0x13, 0x06,
  0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61,
  0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x30, 0x2a, 0x30, 0x05, 0x06, 0x03,
  0x2b, 0x65, 0x70, 0x03, 0x21, 0x00, 0x7f, 0x70, 0xec, 0x0c, 0x2a, 0x76,
  0x07, 0xd3, 0x1a, 0x0b, 0x89, 0xd6, 0x4e, 0x0f, 0x51, 0x4e, 0xf7, 0x88,
  0x7d, 0x45, 0xb3, 0x2b, 0x14, 0x8b, 0x82, 0x25, 0xd0, 0x72, 0xba, 0xf0,
  0x62, 0x08, 0xa3, 0x26, 0x30, 0x24, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d,
  0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x02, 0x84, 0x30, 0x12,
  0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06,
  0x01, 0x01, 0xff, 0x02, 0x01, 0x0a, 0x30, 0x07, 0x06, 0x03, 0x2b, 0x65,
  0x70, 0x05, 0x00, 0x03, 0x41, 0x00, 0xff, 0x25, 0x60, 0x99, 0x2a, 0xb6,
  0x8e, 0x6c, 0xdd, 0x98, 0x74, 0xe9, 0xac, 0x82, 0xb9, 0xe5, 0xe6, 0x32,
  0x63, 0xd4, 0x62, 0x47, 0x72, 0x35, 0x0b, 0x2d, 0x5d, 0x6f, 0xd0, 0x17,
  0xa1, 0x12, 0x3f, 0xef, 0xbd, 0x72, 0x91, 0x70, 0x3b, 0x0e, 0x90, 0x2c,
  0x26, 0xcf, 0x6c, 0xbc, 0xc4, 0x31, 0x7a, 0xaf, 0x3e, 0xd9, 0x1e, 0x0f,
  0xf6, 0x56, 0x0f, 0x1a, 0x88, 0x0d, 0xa3, 0x85, 0x0b, 0x02};

static const unsigned char dev_cert[] = {0x30, 0x82, 0x01, 0x07, 0x30, 0x81,
  0xb8, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x0a, 0x30, 0x07, 0x06,
  0x03, 0x2b, 0x65, 0x70, 0x05, 0x00, 0x30, 0x17, 0x31, 0x15, 0x30, 0x13,
  0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x4d, 0x61, 0x6e, 0x75, 0x66,
  0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x30, 0x1e, 0x17, 0x0d, 0x32,
  0x34, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a,
  0x17, 0x0d, 0x32, 0x37, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30,
  0x30, 0x30, 0x5a, 0x30, 0x18, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55,
  0x04, 0x03, 0x0c, 0x0d, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x6f, 0x66, 0x20,
  0x54, 0x72, 0x75, 0x73, 0x74, 0x30, 0x2a, 0x30, 0x05, 0x06, 0x03, 0x2b,
  0x65, 0x70, 0x03, 0x21, 0x00, 0x4e, 0x08, 0x49, 0xb3, 0xd0, 0x44, 0x1f,
  0x41, 0xf5, 0x3b, 0x94, 0x45, 0x88, 0xf3, 0x89, 0x97, 0xf5, 0x64, 0xbc,
  0x24, 0x4a, 0x7d, 0xe8, 0xa0, 0x15, 0xa4, 0xe8, 0xb6, 0x05, 0xf9, 0xa8,
  0x96, 0xa3, 0x26, 0x30, 0x24, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1d, 0x13,
  0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xff, 0x02, 0x01,
  0x0a, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04,
  0x04, 0x03, 0x02, 0x02, 0x84, 0x30, 0x07, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x05, 0x00, 0x03, 0x41, 0x00, 0xa9, 0xc7, 0x61, 0x08, 0xed, 0xdf, 0xf1,
  0x4c, 0x2b, 0x5b, 0x21, 0x17, 0xa9, 0xe7, 0xd5, 0x29, 0xd4, 0x83, 0xcd,
  0x51, 0x2d, 0x12, 0x3b, 0x37, 0x8a, 0x78, 0x4e, 0xcc, 0xa4, 0xb5, 0x4b,
  0x7a, 0x1d, 0xab, 0x61, 0x67, 0x46, 0xac, 0x97, 0x0e, 0xaa, 0xe0, 0x93,
  0xe3, 0xc5, 0x50, 0x8b, 0x13, 0xe7, 0x0c, 0x97, 0x6b, 0xa2, 0x69, 0xca,
  0x2c, 0xbc, 0x27, 0x37, 0x64, 0x06, 0x36, 0xff, 0x0d};

typedef unsigned char byte;

// Sanctum header fields in DRAM
extern byte sanctum_dev_public_key[32];
extern byte sanctum_dev_secret_key[64];
unsigned int sanctum_sm_size = 0x1ff000;
extern byte sanctum_sm_hash[64];
extern byte sanctum_sm_public_key[32];
extern byte sanctum_sm_secret_key[64];
extern byte sanctum_sm_signature[64];
extern byte sanctum_sm_cert[512];
extern byte sanctum_dev_cert[512];
extern byte sanctum_man_cert[512];
extern int sanctum_sm_cert_len;
extern int sanctum_dev_cert_len;
extern int sanctum_man_cert_len;
#define DRAM_BASE 0x80000000

/* Update this to generate valid entropy for target platform*/
inline byte random_byte(unsigned int i) {
#warning Bootloader does not have entropy source, keys are for TESTING ONLY
  return 0xac + (0xdd ^ i);
}

int bootloader() {
	//*sm_size = 0x200;
  // Reserve stack space for secrets
  byte seed_sm[128];
  sha3_ctx_t hash_ctx;
  byte buf[324];

  int ret;
  // TODO: on real device, copy boot image from memory. In simulator, HTIF writes boot image
  // ... SD card to beginning of memory.
  // sd_init();
  // sd_read_from_start(DRAM, 1024);

  /* Gathering high quality entropy during boot on embedded devices is
   * a hard problem. Platforms taking security seriously must provide
   * a high quality entropy source available in hardware. Platforms
   * that do not provide such a source must gather their own
   * entropy. See the Keystone documentation for further
   * discussion. For testing purposes, we have no entropy generation.
  */

  /* On a real device, the platform must provide a secure root device
     keystore. For testing purposes we hardcode a known private/public
     keypair */
  // TEST Device key
  #include "use_test_keys.h"
  
  // Derive {SK_D, PK_D} (device keys) from a 32 B random seed
  ed25519_create_keypair(sanctum_dev_public_key, sanctum_dev_secret_key, uds);

  // Measure SM
  sha3_init(&hash_ctx, 64);
  sha3_update(&hash_ctx, (void*)DRAM_BASE, sanctum_sm_size);
  sha3_final(sanctum_sm_hash, &hash_ctx);

  // Combine SK_D and H_SM via a hash
  // sm_key_seed <-- H(SK_D, H_SM), truncate to 32B
  sha3_init(&hash_ctx, 64);
  sha3_update(&hash_ctx, sanctum_dev_secret_key, sizeof(*sanctum_dev_secret_key));
  sha3_update(&hash_ctx, sanctum_sm_hash, sizeof(*sanctum_sm_hash));
  sha3_final(seed_sm, &hash_ctx);
  // Derive {SK_D, PK_D} (device keys) from the first 32 B of the hash (NIST endorses SHA512 truncation as safe)
  ed25519_create_keypair(sanctum_sm_public_key, sanctum_sm_secret_key, seed_sm);

  // certificates generation
  mbedtls_x509write_cert cert;
  mbedtls_x509write_crt_init(&cert);

  ret = mbedtls_x509write_crt_set_issuer_name_mod(&cert, "CN=Root of Trust");
  if (ret != 0)
  {
    return 0;
  }

  // Setting the name of the subject of the cert
  ret = mbedtls_x509write_crt_set_subject_name_mod(&cert, "CN=Security Monitor");
  if (ret != 0)
  {
    return 0;
  }

  // pk context used to embed the keys of the security monitor
  mbedtls_pk_context subj_key;
  mbedtls_pk_init(&subj_key);

  // pk context used to embed the keys of the root of trust
  mbedtls_pk_context issu_key;
  mbedtls_pk_init(&issu_key);

  // Parsing the private key of the root of trust that will be used to sign the certificate of the security monitor
  ret = mbedtls_pk_parse_public_key(&issu_key, sanctum_dev_secret_key, 64, 1);
  if (ret != 0)
  {
    return 0;
  }

  ret = mbedtls_pk_parse_public_key(&issu_key, sanctum_dev_public_key, 32, 0);
  if (ret != 0)
  {
    return 0;
  }

  // Parsing the public key of the security monitor that will be inserted in its certificate
  ret = mbedtls_pk_parse_public_key(&subj_key, sanctum_sm_public_key, 32, 0);
  if (ret != 0)
  {
    return 0;
  }

  // Variable  used to specify the serial of the cert
  unsigned char serial[] = {0x01};
  // The public key of the security monitor is inserted in the structure
  mbedtls_x509write_crt_set_subject_key(&cert, &subj_key);

  // The private key of the embedded CA is used later to sign the cert
  mbedtls_x509write_crt_set_issuer_key(&cert, &issu_key);

  // The serial of the cert is setted
  mbedtls_x509write_crt_set_serial_raw(&cert, serial, 1);

  // The algoithm used to do the hash for the signature is specified
  mbedtls_x509write_crt_set_md_alg(&cert, KEYSTONE_SHA3);

  mbedtls_x509write_crt_set_key_usage(&cert, MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN);

  // The validity of the crt is specified
  ret = mbedtls_x509write_crt_set_validity(&cert, "20230101000000", "20250101000000");
  if (ret != 0)
  {
    return 0;
  }

  unsigned char cert_der[1024];
  int effe_len_cert_der;
  size_t len_cert_der_tot = 1024;

  // Variable used to specify the oid of the extension inserted in the cert
  unsigned char oid_ext[] = {0xff, 0x20, 0xff};

  // Adding the measure of the security monitor like extension in its certificate
  //mbedtls_x509write_crt_set_extension(&cert, oid_ext2, 3, 1, max_path, 2);
  mbedtls_x509write_crt_set_basic_constraints(&cert, 1, 10);

  //mbedtls_x509write_crt_set_extension(&cert, oid_ext, 3, 0, sm_hash, 64);

  dice_tcbInfo tcbInfo;
  init_dice_tcbInfo(&tcbInfo);

  measure m;
                                  //\x60  \x86 \x48\x01 \x65  \x03 \x04 \x02  \x0a
  const unsigned char OID_algo[] = {0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x0A};
  memcpy(m.digest, sanctum_sm_hash, 64);
  memcpy(m.OID_algho, OID_algo, 9);
  m.oid_len = 9;

  set_dice_tcbInfo_measure(&tcbInfo, m);


  int dim= sizeof(tcbInfo);

  if(mbedtls_x509write_crt_set_dice_tcbInfo(&cert, tcbInfo, dim, buf, sizeof(buf))!=0)
    return 0;

  // The structure mbedtls_x509write_cert is parsed to create a x509 cert in der format, signed with the private key of the issuer and written in memory
  ret = mbedtls_x509write_crt_der(&cert, cert_der, len_cert_der_tot, NULL, NULL);//, test, &len);
  if (ret != 0)
  {
    effe_len_cert_der = ret;
  }
  else
  {
    return 0;
  }

  unsigned char *cert_real = cert_der;
  // effe_len_cert_der stands for the length of the cert, placed starting from the end of the buffer cert_der
  int dif  = 1024-effe_len_cert_der;
  // cert_real points to the starts of the cert in der format
  cert_real += dif;

  sanctum_sm_cert_len = effe_len_cert_der;
  sanctum_dev_cert_len = 267;
  sanctum_man_cert_len = 267;
  memcpy(sanctum_sm_cert, cert_real, effe_len_cert_der);
  memcpy(sanctum_dev_cert, dev_cert, sanctum_dev_cert_len);
  memcpy(sanctum_man_cert, man_cert, sanctum_man_cert_len);


  // Clean up
  // Erase SK_D
  memset((void*)sanctum_dev_secret_key, 0, sizeof(*sanctum_dev_secret_key));

  // caller will clean core state and memory (including the stack), and boot.
  return 1;
}